{
    "docs": [
        {
            "location": "/", 
            "text": "vcfanno\n\n\n\n[\n]\n\n\nvcfanno annotates a VCF with any number of \nsorted\n and tabixed input BED, BAM, and VCF files in parallel.\nIt does this by finding overlaps as it streams over the data and applying\nuser-defined operations on the overlapping annotations.\n\n\nIn order to parallelize, work is broken down as follows. A slice (array) of query intervals is accumulated \nuntil a specified number is reached (usually ~5K-25K) or a gap cutoff is exceeded; at that point, the\nbounds of the region are used to perform a tabix (or any regional) query on the database files. This is\nall done in \nirelate\n. \nvcfanno\n then iterates over the streams that\nresult from the tabix queries and finds intersections with the query stream. This is a parallel chrom-sweep.\nThis method avoids problems with chromosome order.\n\n\nFor VCF, values are pulled by name from the INFO field.\nFor BED, values are pulled from (1-based) column number.\nFor BAM, depth (\ncount\n), \"mapq\" and \"seq\" are currently supported.\n\n\nvcfanno\n is written in \ngo\n\nIt can annotate more than 8,000 variants per second with 34 annotations from 9 files on a modest laptop.\n\n\nWe are actively developing \nvcfanno\n and appreciate feedback and bug reports.\n\n\nUsage\n\n\nAfter downloading the \nbinary for your system\n (see section below) usage looks like:\n\n\n  ./vcfanno -js example/custom.js example/conf.toml example/query.vcf.gz\n\n\n\n\nWhere conf.toml looks like:\n\n\n[[annotation]]\nfile=\nExAC.vcf\n\nfields = [\nAC_AFR\n, \nAC_AMR\n, \nAC_EAS\n]\nops=[\nfirst\n, \nfirst\n, \nmin\n]\n\n[[annotation]]\nfile=\nfitcons.bed\n\ncolumns = [4, 4]\nnames=[\nfitcons_mean\n, \njs_sum\n]\n# note the 2nd op here is javascript that has access to `vals`\nops=[\nmean\n, \njs:sum=0;for(i=0;i\nvals.length;i++){sum+=vals[i]}; vals\n]\n\n[[annotation]]\nfile=\nexample/ex.bam\n\nnames=[\nex_bam_depth\n]\nfields=[\ndepth\n, \nmapq\n, \nseq\n]\nops=[\ncount\n, \nmean\n, \nconcat\n]\n\n\n\n\nSo from \nExAC.vcf\n we will pull the fields from the info field and apply the corresponding\n\noperation\n from the \nops\n array. Users can add as many \n[[annotation]]\n blocks to the\nconf file as desired. Files can be local as above, or available via http/https.\n\n\nAlso see the additional usage section at the bottom for additional details.\n\n\nExample\n\n\nthe example directory contains the data and conf for a full example. To run, either download\nthe \nappropriate binary\n for your system\nor build with:\n\n\ngo get\ngo build -o vcfanno\n\n\n\n\nfrom this directory.\nThen, you can annotate with:\n\n\nGOMAXPROCS=4 ./vcfanno -js example/custom.js example/conf.toml example/query.vcf.gz \n annotated.vcf\n\n\n\n\nAn example INFO field row before annotation (pos 98683):\n\n\nAB=0.282443;ABP=56.8661;AC=11;AF=0.34375;AN=32;AO=45;CIGAR=1X;TYPE=snp\n\n\n\n\nand after:\n\n\nAB=0.2824;ABP=56.8661;AC=11;AF=0.3438;AN=32;AO=45;CIGAR=1X;TYPE=snp;AC_AFR=0;AC_AMR=0;AC_EAS=0;fitcons_mean=0.061;js_sum=0.061\n\n\n\n\nOperations\n\n\nIn most cases, we will have a single annotation entry for each entry (variant)\nin the query VCF. However, it is possible that there will be multiple annotations\nfrom a single annotation file--in this case, the op determines how the many values\nare \nreduced\n. Valid operations are:\n\n\n\n\njs:$javascript // see section below for more details\n\n\nmean\n\n\nmax\n\n\nmin\n\n\nconcat // comma delimited list of output\n\n\ncount  // count the number of overlaps\n\n\nuniq\n\n\nfirst \n\n\nflag   // presense/absence via vcf flag\n\n\n\n\nBinaries\n\n\nbinary executables are available \nhere\n\nfor \nlinux\n, \nmac\n (darwin), and \nwindows\n for \n32\n and \n64\n bit platforms.\n\n\nPreprocessing\n\n\nAnnotations will be the most accurate if your query and annotation variants are split (no multiple ALTs) and normalize (left-aligned and\ntrimmed). At some point, this will be done internally, but for now, you can get a split and normalized VCF using \nvt\n\nwith:\n\n\nvt decompose -s $VCF | vt normalize -r $REF - \n $NORM_VCF\n\n\n\n\nDevelopment\n\n\nThis, and the associated go libraries (\nvcfgo\n,\n\nirelate\n, \nxopen\n) are\nunder active development. The following are on our radar (most have been completed):\n\n\n\n\n[x] allow annotating with bam fields, e.g. QUAL and SEQ.\n\n\n[ ] decompose, normalize, and get allelic primitives for variants on the fly\n      (we have code to do this, it just needs to be integrated)\n\n\n[ ] allow custom golang ops when using api.\n\n\n[x] improve test coverage for vcfanno (still need more tests for bam)\n\n\n[x] embed otto js engine to allow custom ops.\n\n\n[x] support for annotating BED files.\n\n\n\n\nAdditional Usage\n\n\n-ends\n\n\nFor annotating large variants, such as CNVs or structural variants (SVs), it can be useful to\nannotate the \nends\n of the variant in addition to the region itself. To do this, specify the \n-ends\n\nflag to \nvcfanno\n. e.g.:\n\n\nvcfanno -ends example/conf.toml example/query.vcf.gz\n\n\n\n\nIn this case, the names field in the \nconf\n file contains, \"fitcons_mean\". The output will contain\n\nfitcons\\_mean\n as before along with \nleft\\_fitcons\\_mean\n and \nright\\_fitcons\\_mean\n for any variants\nthat are longer than 1 base. The \nleft\n end will be for the single-base at the lowest base of the variant\nand the \nright\n end will be for the single base at the higher numbered base of the variant.\n\n\n-permissive-overlap\n\n\nBy default, when annotating with a variant, in addition to the overlap requirement, the variants must share\nthe same position, the same reference allele and at least one alternate allele (this is only used for\nvariants, not for BED/BAM annotations). If this flag is specified, only overlap testing is used and shared\nREF/ALT are not required.\n\n\n-p\n\n\nSet to the number of processes that \nvcfanno\n can use during annotation. \nvcfanno\n parallelizes well\nup to 15 or so cores.\n\n\n-js\n\n\ncustom in ops (javascript). For use when the built-in \nops\n don't supply the needed reduction.\n\n\nwe embed the javascript engine \notto\n so that it's \npossible to create a custom op if it is not provided. For example if the users wants to\n\n\n\"js:sum=0;for(i=0;i\nvals.length;i++){sum+=vals[i]};sum\"\n\n\n\nwhere the last value (in this case sum) is returned as the annotation value. It is encouraged\nto instead define javascript functions in separate \n.js\n file and point to it when calling\n\nvcfanno\n using the \n-js\n flag. So, in an external file, \"some.js\", instead put:\n\n\nfunction sum(vals) {\n    s = 0;\n    for(i=0; i\nvals.length; i++){\n        s+=vals[i]\n    }\n    return s\n}\n\n\n\n\nAnd then the above custom op would be: \"js:sum(vals)\". (note that there's a sum op provided\nby \nvcfanno\n which will be faster).\n\n\nThe variables \nvals\n, \nchrom\n, \nstart\n, \nend\n from the current variant will all be available\nin the javascript code.\n\n\nSee \nexample/conf.toml\n\nand \nexample/custom.js\n\nfor more examples.", 
            "title": "Home"
        }, 
        {
            "location": "/#vcfanno", 
            "text": "[ ]  vcfanno annotates a VCF with any number of  sorted  and tabixed input BED, BAM, and VCF files in parallel.\nIt does this by finding overlaps as it streams over the data and applying\nuser-defined operations on the overlapping annotations.  In order to parallelize, work is broken down as follows. A slice (array) of query intervals is accumulated \nuntil a specified number is reached (usually ~5K-25K) or a gap cutoff is exceeded; at that point, the\nbounds of the region are used to perform a tabix (or any regional) query on the database files. This is\nall done in  irelate .  vcfanno  then iterates over the streams that\nresult from the tabix queries and finds intersections with the query stream. This is a parallel chrom-sweep.\nThis method avoids problems with chromosome order.  For VCF, values are pulled by name from the INFO field.\nFor BED, values are pulled from (1-based) column number.\nFor BAM, depth ( count ), \"mapq\" and \"seq\" are currently supported.  vcfanno  is written in  go \nIt can annotate more than 8,000 variants per second with 34 annotations from 9 files on a modest laptop.  We are actively developing  vcfanno  and appreciate feedback and bug reports.", 
            "title": "vcfanno"
        }, 
        {
            "location": "/#usage", 
            "text": "After downloading the  binary for your system  (see section below) usage looks like:    ./vcfanno -js example/custom.js example/conf.toml example/query.vcf.gz  Where conf.toml looks like:  [[annotation]]\nfile= ExAC.vcf \nfields = [ AC_AFR ,  AC_AMR ,  AC_EAS ]\nops=[ first ,  first ,  min ]\n\n[[annotation]]\nfile= fitcons.bed \ncolumns = [4, 4]\nnames=[ fitcons_mean ,  js_sum ]\n# note the 2nd op here is javascript that has access to `vals`\nops=[ mean ,  js:sum=0;for(i=0;i vals.length;i++){sum+=vals[i]}; vals ]\n\n[[annotation]]\nfile= example/ex.bam \nnames=[ ex_bam_depth ]\nfields=[ depth ,  mapq ,  seq ]\nops=[ count ,  mean ,  concat ]  So from  ExAC.vcf  we will pull the fields from the info field and apply the corresponding operation  from the  ops  array. Users can add as many  [[annotation]]  blocks to the\nconf file as desired. Files can be local as above, or available via http/https.  Also see the additional usage section at the bottom for additional details.", 
            "title": "Usage"
        }, 
        {
            "location": "/#example", 
            "text": "the example directory contains the data and conf for a full example. To run, either download\nthe  appropriate binary  for your system\nor build with:  go get\ngo build -o vcfanno  from this directory.\nThen, you can annotate with:  GOMAXPROCS=4 ./vcfanno -js example/custom.js example/conf.toml example/query.vcf.gz   annotated.vcf  An example INFO field row before annotation (pos 98683):  AB=0.282443;ABP=56.8661;AC=11;AF=0.34375;AN=32;AO=45;CIGAR=1X;TYPE=snp  and after:  AB=0.2824;ABP=56.8661;AC=11;AF=0.3438;AN=32;AO=45;CIGAR=1X;TYPE=snp;AC_AFR=0;AC_AMR=0;AC_EAS=0;fitcons_mean=0.061;js_sum=0.061", 
            "title": "Example"
        }, 
        {
            "location": "/#operations", 
            "text": "In most cases, we will have a single annotation entry for each entry (variant)\nin the query VCF. However, it is possible that there will be multiple annotations\nfrom a single annotation file--in this case, the op determines how the many values\nare  reduced . Valid operations are:   js:$javascript // see section below for more details  mean  max  min  concat // comma delimited list of output  count  // count the number of overlaps  uniq  first   flag   // presense/absence via vcf flag", 
            "title": "Operations"
        }, 
        {
            "location": "/#binaries", 
            "text": "binary executables are available  here \nfor  linux ,  mac  (darwin), and  windows  for  32  and  64  bit platforms.", 
            "title": "Binaries"
        }, 
        {
            "location": "/#preprocessing", 
            "text": "Annotations will be the most accurate if your query and annotation variants are split (no multiple ALTs) and normalize (left-aligned and\ntrimmed). At some point, this will be done internally, but for now, you can get a split and normalized VCF using  vt \nwith:  vt decompose -s $VCF | vt normalize -r $REF -   $NORM_VCF", 
            "title": "Preprocessing"
        }, 
        {
            "location": "/#development", 
            "text": "This, and the associated go libraries ( vcfgo , irelate ,  xopen ) are\nunder active development. The following are on our radar (most have been completed):   [x] allow annotating with bam fields, e.g. QUAL and SEQ.  [ ] decompose, normalize, and get allelic primitives for variants on the fly\n      (we have code to do this, it just needs to be integrated)  [ ] allow custom golang ops when using api.  [x] improve test coverage for vcfanno (still need more tests for bam)  [x] embed otto js engine to allow custom ops.  [x] support for annotating BED files.", 
            "title": "Development"
        }, 
        {
            "location": "/#additional-usage", 
            "text": "", 
            "title": "Additional Usage"
        }, 
        {
            "location": "/#-ends", 
            "text": "For annotating large variants, such as CNVs or structural variants (SVs), it can be useful to\nannotate the  ends  of the variant in addition to the region itself. To do this, specify the  -ends \nflag to  vcfanno . e.g.:  vcfanno -ends example/conf.toml example/query.vcf.gz  In this case, the names field in the  conf  file contains, \"fitcons_mean\". The output will contain fitcons\\_mean  as before along with  left\\_fitcons\\_mean  and  right\\_fitcons\\_mean  for any variants\nthat are longer than 1 base. The  left  end will be for the single-base at the lowest base of the variant\nand the  right  end will be for the single base at the higher numbered base of the variant.", 
            "title": "-ends"
        }, 
        {
            "location": "/#-permissive-overlap", 
            "text": "By default, when annotating with a variant, in addition to the overlap requirement, the variants must share\nthe same position, the same reference allele and at least one alternate allele (this is only used for\nvariants, not for BED/BAM annotations). If this flag is specified, only overlap testing is used and shared\nREF/ALT are not required.", 
            "title": "-permissive-overlap"
        }, 
        {
            "location": "/#-p", 
            "text": "Set to the number of processes that  vcfanno  can use during annotation.  vcfanno  parallelizes well\nup to 15 or so cores.", 
            "title": "-p"
        }, 
        {
            "location": "/#-js", 
            "text": "custom in ops (javascript). For use when the built-in  ops  don't supply the needed reduction.  we embed the javascript engine  otto  so that it's \npossible to create a custom op if it is not provided. For example if the users wants to  \"js:sum=0;for(i=0;i vals.length;i++){sum+=vals[i]};sum\"  where the last value (in this case sum) is returned as the annotation value. It is encouraged\nto instead define javascript functions in separate  .js  file and point to it when calling vcfanno  using the  -js  flag. So, in an external file, \"some.js\", instead put:  function sum(vals) {\n    s = 0;\n    for(i=0; i vals.length; i++){\n        s+=vals[i]\n    }\n    return s\n}  And then the above custom op would be: \"js:sum(vals)\". (note that there's a sum op provided\nby  vcfanno  which will be faster).  The variables  vals ,  chrom ,  start ,  end  from the current variant will all be available\nin the javascript code.  See  example/conf.toml \nand  example/custom.js \nfor more examples.", 
            "title": "-js"
        }, 
        {
            "location": "/examples/clinvar_exac/", 
            "text": "Annotate Clinvar With ExAC\n\n\nThe \nExAC paper\n notes that\nsome of the variants in \nClinVar\n that \nare classified as pathogenic (or likely pathogenic) are actually in high enough (\n1%)\nallele frequency in ExAC to indicate that it is unlikely that these are really pathogenic.\n\n\nHere, we will use \nvcfanno\n to annotate the clinvar VCF with the allele frequencies\nfor ExAC so that we can find variants that are indicated as pathogenic \nand\n rare in ExAC.\n\n\nThe ExAC reports the alternate counts and the total number of chromosomes (\nAN*\n) and the\nalternate allele counts (\nAC*\n) so, to we will annotate with those and then use \npostannotation\n\nin \nvcfanno\n to get the \nAF\n as \nAC/AN\n. We will use\nan already \ndecomposed and normalized\n version of\nExAC (but vcfanno will match on any of the alternate alleles if multiple are present for a given\nvariant). The \n[[annotation]]\n section in the config file will look like this:\n\n\nExAC Config\n\n\n[[annotation]]\nfile=\nExAC.r0.3.sites.vep.tidy.vcf.gz\n\nfields = [\nAC_Adj\n, \nAN_Adj\n, \nAC_AFR\n, \nAN_AFR\n, \nAC_AMR\n, \nAN_AMR\n, \nAC_EAS\n, \nAN_EAS\n, \nAC_FIN\n, \nAN_FIN\n, \nAC_NFE\n, \nAN_NFE\n, \nAC_OTH\n, \nAN_OTH\n, \nAC_SAS\n, \nAN_SAS\n]\nnames = [\nac_exac_all\n, \nan_exac_all\n, \nac_exac_afr\n, \nan_exac_afr\n, \nac_exac_amr\n, \nan_exac_amr\n, \nac_exac_eas\n, \nan_exac_eas\n, \nac_exac_fin\n, \nan_exac_fin\n, \nac_exac_nfe\n, \nan_exac_nfe\n, \nac_exac_oth\n, \nan_exac_oth\n, \nac_exac_sas\n, \nan_exac_sas\n]\nops=[\nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n, \nself\n]\n\n\n\n\nNote that we can have as many of these sections as we want with vcfanno, but here we are only\ninterested in annotating clinvar with a single file. The \nfields\n section indicates which fields to\npull from the \nExAC\n VCF. The \nnames\n section indicates how those fields will be named as they are\nadded to the clinvar VCF. Since we intend to match on REF and ALT, there will only be 1 match so the\n\nop\n is just \"self\" for all fields.\n\n\nBecause we want to know the allele frequency, we will need to divide \nAC\n by \nAN\n. This is done in a \n[[postannotation]]\n\nsection that looks like this:\n\n\nPostAnnotation\n\n\n[[postannotation]]\nfields=[\nac_exac_all\n, \nan_exac_all\n]\nname=\naf_exac_all\n\nop=\ndiv2\n\ntype=\nFloat\n\n\n\n\n\nWe need one of these section for each population, which is onerous, but simple enough to generate with\na small script. Note that the op \ndiv2\n is provided by \nvcfanno\n, but we could have written this as a\ncustom op in javascript as:\n\n\nfunction div2(a, b) {\n    if(a == 0){ return 0.0; }\n    return (a / b).toFixed(9)\n}\n\n\n\n\nand then use:\n\n\nop=\njs:div2\n\n\n\n\n\nin the \n[[postannotation]]\n.\n\n\nThese \npostannotation\n sections are executed in the order they are specified so we can specify a final section that\ntakes the maximum of all of the allele frequencies. This is informative as a truly pathogenic variant should have a\nlow allele frequency in all populations. Here is the section to take the maximum AF of all the populations which\nwe've already calculated:\n\n\n[[postannotation]]\nfields=[\naf_exac_all\n, \naf_exac_afr\n, \naf_exac_amr\n, \naf_exac_eas\n, \naf_exac_nfe\n, \naf_exac_oth\n, \naf_exac_sas\n]\nop=\nmax\n\nname=\nmax_aaf_all\n\ntype=\nFloat\n\n\n\n\n\nFlag Common Pathogenic\n\n\nFinally, we can flag variants that have a \nmax_aaf_all\n above some cutoff and are labelled as pathogenic.\n\n\n[[postannotation]]\nfields=[\nclinvar_sig\n, \nmax_aaf_all\n]\nop=\njs:check_clinvar_aaf(clinvar_sig, max_aaf_all, 0.005)\n\nname=\ncommon_pathogenic\n\ntype=\nFlag\n\n\n\n\n\nNote that we use 0.005 as the allele frequency cutoff. For any variant that was not present in ExAC, the \nmax_aaf_all\n field\nwill be absent from the INFO field and so this will not be called.\n\n\nIf we've saved this in a file called \nexac-af.conf\n then the vcfanno command looks like:\n\n\nvcfanno -js clinvar_exac.js -p 4 -base-path $EXAC_DIR clinvar_exac.conf $CLINVAR_VCF \n $CLINVAR_ANNOTATED_VCF\n\n\n\n\nThis command finishes in about 2 minutes on a good laptop with a core i7 processor.\n\n\nAn example INFO field from the clinvar file after annotation looks like this:\n\n\nRS=17855739;RSPOS=5831840;RV;dbSNPBuildID=123;SSR=0;SAO=1;VP=0x050060000a05150136110100;GENEINFO=FUT6:2528;WGT=1;VC=SNV;PM;NSM;REF;ASP;VLD;G5;GNO;KGPhase1;KGPhase3;LSD;OM;CLNALLE=1;CLNHGVS=NC_000019.9:g.5831840C\nT;CLNSRC=OMIM_Allelic_Variant;CLNORIGIN=1;CLNSRCID=136836.0001;CLNSIG=5;CLNDSDB=MedGen:OMIM;CLNDSDBID=C3151219:613852;CLNDBN=Fucosyltransferase_6_deficiency;CLNREVSTAT=single;CLNACC=RCV000017626.26;CAF=0.8393,0.1607;COMMON=1;ac_exac_all=10114;an_exac_all=121354;ac_exac_afr=3093;an_exac_afr=10402;ac_exac_amr=449;an_exac_amr=11572;ac_exac_eas=867;an_exac_eas=8638;ac_exac_fin=210;an_exac_fin=6612;ac_exac_nfe=2836;an_exac_nfe=66712;ac_exac_oth=62;an_exac_oth=906;ac_exac_sas=2597;an_exac_sas=16512;af_exac_all=0.0833;af_exac_afr=0.2973;af_exac_amr=0.0388;af_exac_eas=0.1004;af_exac_nfe=0.0425;af_exac_oth=0.0684;af_exac_sas=0.1573;max_aaf_all=0.2973;clinvar_sig=pathogenic;common_pathogenic\n\n\n\n\n(NOTE that clinvar has applied the \nCOMMON=1\n tag here indicating a high AF in 1kg.)\n\n\nWith our ExAC fields appearing at the end:\n\n\nac_exac_all=10114;an_exac_all=121354;ac_exac_afr=3093;an_exac_afr=10402;ac_exac_amr=449;an_exac_amr=11572;ac_exac_eas=867;an_exac_eas=8638;ac_exac_fin=210;an_exac_fin=6612;ac_exac_nfe=2836;an_exac_nfe=66712;ac_exac_oth=62;an_exac_oth=906;ac_exac_sas=2597;an_exac_sas=16512;af_exac_all=0.0833;af_exac_afr=0.2973;af_exac_amr=0.0388;af_exac_eas=0.1004;af_exac_nfe=0.0425;af_exac_oth=0.0684;af_exac_sas=0.1573;max_aaf_all=0.2973;clinvar_sig=pathogenic;common_pathogenic\n\n\n\n\nSo this variant was classified as pathogenic, but has a \nmax_aaf_all\n of 0.2973.\n\n\nWhile the config file used to generate this final dataset was fairly involved, each step is very simple and it shows the power in vcfanno.\nHowever, note that for most analyses, it will be sufficient to specify a config file that pulls the \n\n\nSupporting Files\n\n\nThe full config and javascript files used to run this analysis are available \nhere\n.", 
            "title": "ClinvarExac"
        }, 
        {
            "location": "/examples/clinvar_exac/#annotate-clinvar-with-exac", 
            "text": "The  ExAC paper  notes that\nsome of the variants in  ClinVar  that \nare classified as pathogenic (or likely pathogenic) are actually in high enough ( 1%)\nallele frequency in ExAC to indicate that it is unlikely that these are really pathogenic.  Here, we will use  vcfanno  to annotate the clinvar VCF with the allele frequencies\nfor ExAC so that we can find variants that are indicated as pathogenic  and  rare in ExAC.  The ExAC reports the alternate counts and the total number of chromosomes ( AN* ) and the\nalternate allele counts ( AC* ) so, to we will annotate with those and then use  postannotation \nin  vcfanno  to get the  AF  as  AC/AN . We will use\nan already  decomposed and normalized  version of\nExAC (but vcfanno will match on any of the alternate alleles if multiple are present for a given\nvariant). The  [[annotation]]  section in the config file will look like this:", 
            "title": "Annotate Clinvar With ExAC"
        }, 
        {
            "location": "/examples/clinvar_exac/#exac-config", 
            "text": "[[annotation]]\nfile= ExAC.r0.3.sites.vep.tidy.vcf.gz \nfields = [ AC_Adj ,  AN_Adj ,  AC_AFR ,  AN_AFR ,  AC_AMR ,  AN_AMR ,  AC_EAS ,  AN_EAS ,  AC_FIN ,  AN_FIN ,  AC_NFE ,  AN_NFE ,  AC_OTH ,  AN_OTH ,  AC_SAS ,  AN_SAS ]\nnames = [ ac_exac_all ,  an_exac_all ,  ac_exac_afr ,  an_exac_afr ,  ac_exac_amr ,  an_exac_amr ,  ac_exac_eas ,  an_exac_eas ,  ac_exac_fin ,  an_exac_fin ,  ac_exac_nfe ,  an_exac_nfe ,  ac_exac_oth ,  an_exac_oth ,  ac_exac_sas ,  an_exac_sas ]\nops=[ self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ,  self ]  Note that we can have as many of these sections as we want with vcfanno, but here we are only\ninterested in annotating clinvar with a single file. The  fields  section indicates which fields to\npull from the  ExAC  VCF. The  names  section indicates how those fields will be named as they are\nadded to the clinvar VCF. Since we intend to match on REF and ALT, there will only be 1 match so the op  is just \"self\" for all fields.  Because we want to know the allele frequency, we will need to divide  AC  by  AN . This is done in a  [[postannotation]] \nsection that looks like this:", 
            "title": "ExAC Config"
        }, 
        {
            "location": "/examples/clinvar_exac/#postannotation", 
            "text": "[[postannotation]]\nfields=[ ac_exac_all ,  an_exac_all ]\nname= af_exac_all \nop= div2 \ntype= Float   We need one of these section for each population, which is onerous, but simple enough to generate with\na small script. Note that the op  div2  is provided by  vcfanno , but we could have written this as a\ncustom op in javascript as:  function div2(a, b) {\n    if(a == 0){ return 0.0; }\n    return (a / b).toFixed(9)\n}  and then use:  op= js:div2   in the  [[postannotation]] .  These  postannotation  sections are executed in the order they are specified so we can specify a final section that\ntakes the maximum of all of the allele frequencies. This is informative as a truly pathogenic variant should have a\nlow allele frequency in all populations. Here is the section to take the maximum AF of all the populations which\nwe've already calculated:  [[postannotation]]\nfields=[ af_exac_all ,  af_exac_afr ,  af_exac_amr ,  af_exac_eas ,  af_exac_nfe ,  af_exac_oth ,  af_exac_sas ]\nop= max \nname= max_aaf_all \ntype= Float", 
            "title": "PostAnnotation"
        }, 
        {
            "location": "/examples/clinvar_exac/#flag-common-pathogenic", 
            "text": "Finally, we can flag variants that have a  max_aaf_all  above some cutoff and are labelled as pathogenic.  [[postannotation]]\nfields=[ clinvar_sig ,  max_aaf_all ]\nop= js:check_clinvar_aaf(clinvar_sig, max_aaf_all, 0.005) \nname= common_pathogenic \ntype= Flag   Note that we use 0.005 as the allele frequency cutoff. For any variant that was not present in ExAC, the  max_aaf_all  field\nwill be absent from the INFO field and so this will not be called.  If we've saved this in a file called  exac-af.conf  then the vcfanno command looks like:  vcfanno -js clinvar_exac.js -p 4 -base-path $EXAC_DIR clinvar_exac.conf $CLINVAR_VCF   $CLINVAR_ANNOTATED_VCF  This command finishes in about 2 minutes on a good laptop with a core i7 processor.  An example INFO field from the clinvar file after annotation looks like this:  RS=17855739;RSPOS=5831840;RV;dbSNPBuildID=123;SSR=0;SAO=1;VP=0x050060000a05150136110100;GENEINFO=FUT6:2528;WGT=1;VC=SNV;PM;NSM;REF;ASP;VLD;G5;GNO;KGPhase1;KGPhase3;LSD;OM;CLNALLE=1;CLNHGVS=NC_000019.9:g.5831840C T;CLNSRC=OMIM_Allelic_Variant;CLNORIGIN=1;CLNSRCID=136836.0001;CLNSIG=5;CLNDSDB=MedGen:OMIM;CLNDSDBID=C3151219:613852;CLNDBN=Fucosyltransferase_6_deficiency;CLNREVSTAT=single;CLNACC=RCV000017626.26;CAF=0.8393,0.1607;COMMON=1;ac_exac_all=10114;an_exac_all=121354;ac_exac_afr=3093;an_exac_afr=10402;ac_exac_amr=449;an_exac_amr=11572;ac_exac_eas=867;an_exac_eas=8638;ac_exac_fin=210;an_exac_fin=6612;ac_exac_nfe=2836;an_exac_nfe=66712;ac_exac_oth=62;an_exac_oth=906;ac_exac_sas=2597;an_exac_sas=16512;af_exac_all=0.0833;af_exac_afr=0.2973;af_exac_amr=0.0388;af_exac_eas=0.1004;af_exac_nfe=0.0425;af_exac_oth=0.0684;af_exac_sas=0.1573;max_aaf_all=0.2973;clinvar_sig=pathogenic;common_pathogenic  (NOTE that clinvar has applied the  COMMON=1  tag here indicating a high AF in 1kg.)  With our ExAC fields appearing at the end:  ac_exac_all=10114;an_exac_all=121354;ac_exac_afr=3093;an_exac_afr=10402;ac_exac_amr=449;an_exac_amr=11572;ac_exac_eas=867;an_exac_eas=8638;ac_exac_fin=210;an_exac_fin=6612;ac_exac_nfe=2836;an_exac_nfe=66712;ac_exac_oth=62;an_exac_oth=906;ac_exac_sas=2597;an_exac_sas=16512;af_exac_all=0.0833;af_exac_afr=0.2973;af_exac_amr=0.0388;af_exac_eas=0.1004;af_exac_nfe=0.0425;af_exac_oth=0.0684;af_exac_sas=0.1573;max_aaf_all=0.2973;clinvar_sig=pathogenic;common_pathogenic  So this variant was classified as pathogenic, but has a  max_aaf_all  of 0.2973.  While the config file used to generate this final dataset was fairly involved, each step is very simple and it shows the power in vcfanno.\nHowever, note that for most analyses, it will be sufficient to specify a config file that pulls the", 
            "title": "Flag Common Pathogenic"
        }, 
        {
            "location": "/examples/clinvar_exac/#supporting-files", 
            "text": "The full config and javascript files used to run this analysis are available  here .", 
            "title": "Supporting Files"
        }
    ]
}